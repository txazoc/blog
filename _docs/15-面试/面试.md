### 面试

#### Java

* ConcurrentHashMap(jdk8)
    * put: 数组(cas + volatile)、synchronized、链表(红黑树)
    * get: 数组(volatile)、value(volatile)
* 线程栈状态: RUNNABLE、BLOCKED、WAITING、TIMED_WAITING
* 线程池: 五大核心参数、四种拒绝策略
    * 线程池中线程不要对外抛出异常(导致线程销毁/创建)
* 调度线程池: DelayedWorkQueue、优先级队列
* 线程数大小: CPU密集型(CPU * 1 ~ 2)、IO密集型(最佳线程数目 = ((线程等待时间 + 线程CPU时间) / 线程CPU时间) * CPU核心数)
* Future: 等待队列、park/unpark
* IO: 5种IO模型
* 序列化对比: jdk序列化、xml、json、Hessian、Thrift/ProtoBuf，时间、空间、描述文件、友好
* 原子性、可见性、有序性
* volatile: 可见性(缓存一致性协议)、禁止指令重排序(内存屏障)
* CAS: 原子性、禁止指令重排序、自旋CAS
* AQS: state、CAS、CLH同步队列、park/unpark、独占/共享
* 双重检查锁: 重排序问题、volatile
* synchronized & Lock
    * 加解锁: 隐式加锁解锁(关键字、monitorenter、monitorexit、ACC_SYNCHRONIZED方法标识)、显式加锁解锁(代码)
    * 用法: synchronized(三种用法)、lock/lockInterruptibly/tryLock/tryLock(time)
    * 锁类型: 锁升级(偏向锁、轻量级锁、自旋锁、重量级锁)、公平锁/非公平锁/读写锁
    * 优化: synchronized(锁消除、锁粗化)
    * 实现
        * synchronized: 对象头、偏向锁(CAS 对象头`Thread Id`)、轻量级锁(CAS 对象头`Mark Word`)、自旋锁(轻量级锁重试)、重量级锁(监视器锁、block阻塞队列、wait等待队列)
        * Lock: AQS、公平锁(抢占)/非公平锁(排队)/读写锁(state=高低位读锁写锁数量)
    * 等待/唤醒: 一个wait/notify等待队列、多个Condition等待队列
* 多线程同步: 不可变、局部变量、ThreadLocal、volatile、CAS、锁、AQS(Semaphore、CountDownLatch、CyclicBarrier、Condition)、wait/notify、join、concurrent包
* Java命令: jstack、jmap、jhat
* Reference
    * DirectByteBuffer -> Cleaner

#### JVM

* JVM内存结构: 程序计数器、Java虚拟机栈、本地方法栈、堆、方法区、Metaspace(本地内存)
* `类加载`: 双亲委派、.class字节码、类文件格式(解析验证)、先加载父类
    * 准备: 类静态变量分配内存空间、静态基本类型常量赋值
    * 初始化: 静态代码块、静态变量、静态引用类型常量
* `对象初始化`: 分配内存空间、父类构造代码块/成员变量、父类构造方法、子类...
* GC Roots: 栈(线程栈帧、本地方法栈)、方法区(static变量、常量池)
* 垃圾收集算法: 复制、标记-整理、标记-清除
* young gc为什么快: 扫描对象少(线程栈 + Dirty Card)、存活对象少(copy少)
* 8种垃圾收集器:
    * Serial、Serial Old、ParNew、Parallel Scavenge、Parallel Old、CMS、G1
    * 新生代/老年代、串行/并行/并发、STW、垃圾收集算法
    * 垃圾收集器组合
* CMS: 4个过程
* 内存分配
    * 新生代: 新的对象
    * 老年代: 长期存活晋级的对象、大对象、Minor GC空间分配担保
* Minor GC
    * 新生代eden内存空间不足
    * -XX:+CMSScavengeBeforeRemark: 在执行CMS Remark前执行一次Young GC，减少GC Roots的数量，降低Remark的开销
    * Full GC时会先触发Minor GC，适用于`+UseParallelGC`
* Full GC
    * System.gc()
    * 老年代空间不足
    * 永久代空间不足
    * Minor GC前，老年代剩余空间小于历史晋升到老年代对象的平均大小
    * CMS GS promotion failed，Minor GC时，晋升对象/担保对象进入老年代，因碎片问题，无法分配内存空间，触发CMS Full GC
    * CMS GS concurrent mode failure，CMS GC时，大对象直接进入老年代，老年代空间不足，此时CMS GC退化为Serial Old GC
* JVM调优
    * 调优目标: gc时间、gc频率、吞吐量、停顿时间
    * 调什么: 代码层面(对象)、垃圾收集器选择、参数调整(内存大小及比例、线程数、其它)
* OOM内存溢出
    * 内存未释放
    * 资源未释放
    * 加载过多匿名类未卸载

#### 网络通信

* TCP: 三次握手、四次挥手、滑动窗口、数据包重组、重传
* TCP直连、HTTP连接池(长连接)

#### 开源框架

* Spring IOC
    * 扫描BeanDefinition、实例化bean、注入依赖、初始化bean(@PostConstruct、afterPropertiesSet()、init-method)
    * 循环依赖: singletonObjects、earlySingletonObjects、singletonFactories、构造器的循环依赖没法解决
* Spring AOP: 切入点Pointcut + 增强Advice(前置增强、后置增强、环绕增强、异常增强)
* Spring事务: AOP、Spring事务传播机制、事务管理、commit、rollback
* Netty
    * Reactor模型: boss线程池(accept)、worker线程池(io读写、Handler事件链)、自定义Handler处理线程池
    * Handler事件驱动(Inbound、Outbound)、拆包粘包、ByteBuf(Zero Copy、池化)
* Tomcat: maxConnections(10000)、maxThreads(200)
* LVS: NAT、DR、TUN

#### 微服务

* Ribbon: 随机、轮询、加权响应时间、最小并发数
* Hystrix: 隔离、限流(信号量、线程池)、熔断(滑动时间窗口)、降级
    * 断路器状态: OPEN、HALF_OPEN、CLOSED
* Eureka: 服务提供者(心跳、replication)、服务消费者(refresh)、Server(去中心化)
* Eureka Server三级缓存
    * registry: 注册表
    * readWriterCacheMap: 读写缓存
    * readOnlyCacheMap: 只读缓存(可禁用)
* Eureka缓存
    * Ribbon缓存: client.ribbon.ServerListRefreshInterval=30s
    * Eureka Client缓存: eureka.client.registry-fetch-interval-seconds=30s
    * Eureka Server缓存: eureka.server.response-cache-update-interval-ms=30s

#### 分布式

* CAP: C一致性(多副本一致)、A可用性(有限时间内返回正常结果)、P分区容错性(网络分区)
    * 分布式环境下，必须保证P，在C和A之间取舍
    * 保证可用性N个9、保证AP，牺牲C(强一致性)
* BASE: CAP理论的延伸，保证最终一致性
    * BA: 基本可用(Basically Available)，允许响应时间上的损失、功能损失(降级)
    * S: 软状态(Soft State)，允许存在中间状态
    * E: 最终一致性(Eventual Consistent)，弱一致性，保证最终一致性
* 分布式ID: UUID、redis incr、数据库分表步长、数据库发号器、雪花算法(1+41+10+12时钟回拨)
* 分布式事务: 两阶段提交、TCC、RocketMQ事务消息、本地消息表(MQ、轮询)
* 分布式锁: 可重入、阻塞、超时释放、单点问题
    * MySQL唯一索引、InnoDB排他锁
    * redis: setnx、Redission(lua、clientId、count、watch dog)、redlock(n/2 + 1)
    * Zookeeper: 临时顺序节点、watch
* Zookeeper选举算法: epoch、zxid、sid
* Zookeeper应用: 命名服务、配置管理(元数据)、集群管理(注册中心)、分布式锁、分布式队列
* 限流: AtomicInteger、Semaphore、令牌桶(RateLimiter)、漏桶、缓存限流(时间窗口)
* 幂等: 分布式锁、redis去重(requestId)、数据库唯一性约束、状态机、多版本

#### MySQL

* B+Tree: 一页(16k)、树的高度、范围查询
* 索引
    * 聚集索引、非聚集索引、二级索引、联合索引、前缀索引、覆盖索引、回表
    * 避免过多、优先整数、索引尽量小、索引列基数足够大(否则导致大量的回表操作)、最好自增
* SQL优化: explain、join、where、like、表达式、order(索引排序)、limit(避免大的offset)
* explain
    * type: const(唯一索引)、eq_ref(唯一索引join)、ref(非唯一二级索引查询/join)、index_merge(索引查询合并)、range(索引范围查询)、index(全表扫描索引树)、ALL(全表扫描)
    * Extra: Using filesort(文件排序)、Using temporary(临时表)、Using index(覆盖索引)
* 读写分离: 读压力
* 主从同步
    * 主binlog -> 从relay log -> 从执行SQL
    * 异步复制、半同步复制、全同步复制
* 分库分表
    * 水平切分/垂直切分、数据量大、读写压力
    * 带来的问题: 分布式事务、跨节点join/order/limit、ID生成、扩容、分片策略
* Log
    * Redo Log(崩溃恢复): `innodb_flush_log_at_trx_commit`
    * Undo Log(回滚、MVCC)、binlog(主从同步)、慢查询日志
* ACID
* MVCC: 版本链、ReadView
* 锁
    * 表锁、意向锁、行锁
    * 记录锁、间隙锁、Next-Key锁、插入意向锁(幻读、并发)
    * 共享锁(S锁)、排它锁(X锁)
    * 悲观锁、乐观锁
* 事务隔离级别
    * READ UNCOMMITTED: select不加锁
    * READ COMMITTED: 一致性非锁定读(当前读)
    * REPEATABLE READ: 一致性非锁定读(快照读)，加Gap锁/Next-Key锁
    * SERIALIZABLE
* 一致性非锁定读(MVCC)、一致性锁定读(锁)

#### Redis

* 单线程原因: 内存读写快、线程上下文切换开销、IO多路复用、并发冲突
* Redis Cluster: 16384个槽、mget(大括号)
* 避免大的value: 占用内存过大(导致淘汰)、IO
* 缓存穿透、缓存失效、缓存雪崩
* 热点缓存
    * 压力: 本地缓存、缓存多份数据
    * 失效导致数据库压力: 持久缓存、数据库限流、失效时间分散化、失效预填充
* 持久化: RDB(fork子进程)、AOF
* Pipeline
* 过期键删除策略: 惰性删除、定期删除
* `内存淘汰机制`
    * volatile-lru、volatile-ttl、volatile-random
    * allkeys-lru、allkeys-random
    * no-eviction

#### ElasticSearch

* Lucene索引结构: Term Index(term前缀)、Term Dictionary(二分查找)、Posting List
* 字段: 精确值/全文、Multi-Field
* routing
* 避免深度分页、scroll
* 查询: term查询、filter查询(缓存)、bool查询(must、must_not、should、filter)
    * filter查询: 不计算_score，结果被缓存
    * query查询: 计算_score，结果不被缓存
* Lucene索引
    * 一个提交点(Commit Point)、多个段(Segment)
    * 一个提交点记录所有已提交的段，包含一个`.del`文件
    * 一个段包含多个字段的倒排索引，可以被搜索
* 写数据: 写`in-memory buffer`、记录translog
* refresh: `in-memory buffer` -> `Segment(os buffer)`
* flush: Segment(os buffer)fsync到磁盘，清空translog
* translog: 每5s落盘

#### Kafka

* 解耦、削峰、异步化
* 高性能: batch批量发送、网络模型、零拷贝、内存文件映射、磁盘顺序IO(读写)、批量消费
* 消息可靠投递:
    * ack=-1、retry>0(重试间隔大一点)
    * replicas>1、`min.insync.replicas`>1、OSR不参与Master选举
    * 刷盘
        * log.flush.interval.messages
        * log.flush.interval.ms
        * log.flush.scheduler.interval.ms
    * 关闭自动commit、幂等
* 消息重复: Server幂等、Consumer幂等
* Kafka幂等实现
    * `Producer Id`
    * <Topic, Partition>: 自增`Sequence Number`
    * Broker: 缓存的`Sequence Number` + 1 = 接收消息的`Sequence Number`
* HW(ISR中最小的LEO)、LEO(分区中下一条消息的offset)

#### 高性能

* 指标: QPS、响应时间
* 单机: CPU、IO
* 集群: 负载均衡

#### 高可用(4个9)

* 避免单点故障: 负载均衡、多机房、异地多活
* 存储: 数据分片、冗余备份、读写分离
* 压测
* 监控自动报警
* 隔离(进程隔离、线程池隔离)/限流/熔断/降级
* 超时/失败重试

#### 高并发

* 海量数据
* 高并发要求`高性能`
* 高并发要求`高可用`
* 高并发要求`可扩展`
* 高并发保证`数据一致性`

#### 微服务 & SOA

* 通信方式: ESB企业服务总线 去中心化(服务与服务直接通信)
* 服务划分粒度: 粗粒度 细粒度(拆分、快速迭代、扩展、隔离)
* 容器支持: 持续集成、自动化测试、自动化部署、扩容

#### 故障排查

* CPU: 是否飙高、top、jstack
* 频繁gc: gc log
* 内存溢出OOM: +HeapDumpOnOutOfMemoryError、jmap、jhat、MAT、大对象
    * 自增长的数据结构
    * 内存泄露(引用未释放)
    * 装载太多的类
    * 直接内存
* 业务异常: 业务日志

https://blog.csdn.net/h70614959/article/details/83109317

#### 离职原因

* 管理混乱、产品进度慢、不稳定、没有太大的前景
