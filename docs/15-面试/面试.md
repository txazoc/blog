### 面试

#### Java

* 线程栈状态: RUNNABLE、BLOCKED、WAITING、TIMED_WAITING
* 线程池: 五大核心参数、四种拒绝策略
* 调度线程池: DelayedWorkQueue、优先级队列
* 线程数大小: CPU密集型(CPU * 1 ~ 2)、IO密集型(最佳线程数目 = ((线程等待时间 + 线程CPU时间) / 线程CPU时间) * CPU核心数)
* IO: 5种IO模型
* 序列化对比: jdk序列化、xml、json、Hessian、Thrift/ProtoBuf，时间、空间、描述文件、友好
* volatile: 可见性、禁止指令重排序
* CAS: 原子性、禁止指令重排序、自旋CAS
* AQS: state、CAS、CLH同步队列、park/unpark
* 双重检查锁: 重排序问题、volatile
* synchronized: 偏向锁、轻量级锁、自旋锁、重量级锁
* Lock: lockInterruptibly、tryLock
* synchronized & Lock
    * synchronized: 隐式加锁解锁、锁升级(不可逆)、一个wait/notify队列、优化(锁消除、锁粗化)
    * Lock: 显式加锁解锁、多个API(try、中断)、多个Condition队列
* 多线程同步: 不可变、局部变量、ThreadLocal、volatile、CAS、原子类、锁、AQS(Semaphore、CountDownLatch、CyclicBarrier、Condition)、wait/notify、concurrent包
* Java命令: jstack、jmap、jhat
* Reference
    * DirectByteBuffer -> Cleaner

#### JVM

* JVM内存结构: 程序计数器、Java虚拟机栈、本地方法栈、堆、方法区、Metaspace(本地内存)
* 类加载: 双亲委派、.class字节码、类文件格式(解析验证)、类静态变量分配内存空间并赋默认值
* 类初始化: `<clinit>`(static变量、static代码块)、先初始化父类
* 对象初始化: 、
* 垃圾收集算法: 复制、标记-整理、标记-清除
* young gc为什么快: 扫描对象少(线程栈 + Dirty Card)、存活对象少(copy少)
* 8种垃圾收集器:
    * Serial、Serial Old、ParNew、Parallel Scavenge、Parallel Old、CMS、G1
    * 新生代/老年代、串行/并行/并发、STW、垃圾收集算法
    * 垃圾收集器组合
* CMS: 4个过程
* 内存分配
    * 新生代: 新的对象
    * 老年代: 长期存活晋级的对象、大对象、Minor GC空间分配担保
* Minor GC
    * 新生代eden内存空间不足
    * -XX:+CMSScavengeBeforeRemark: 在执行CMS Remark前执行一次Young GC，减少老年代对新生代的引用，降低Remark的开销
    * Full GC时会先触发Minor GC，适用于UseParallelGC
* Full GC
    * System.gc()
    * 老年代空间不足
    * 永久代空间不足
    * CMS GS promotion failed，Minor GC时，晋升对象/担保对象进入老年代，因碎片问题，无法分配内存空间，触发CMS Full GC
    * CMS GS concurrent mode failure，CMS GC时，大对象直接进入老年代，老年代空间不足，此时CMS退化为Serial Old
* JVM调优
    * 调优目标: gc时间、gc频率、吞吐量、停顿时间
    * 调什么: 代码层面(对象)、垃圾收集器选择、参数调整(内存大小及比例、线程数、其它)

#### 开源框架

* Spring IOC: 循环依赖
* Spring事务: AOP、Spring事务隔离级别、事务管理、commit、rollback
* Netty: Reactor模型、Handler事件驱动、拆包粘包、DirectByteBuffer

#### 微服务

* Ribbon
* Hystrix: 限流实现(信号量、线程池)、熔断实现(滑动时间窗口)
* Eureka: 服务提供者(心跳、replication)、服务消费者(refresh)、Server(注册表、去中心化)

#### 分布式

* 分布式ID: UUID、redis incr、数据库分表步长、数据库发号器、雪花算法
* 分布式事务: 两阶段提交、TCC、RocketMQ事务消息、本地事务
* 分布式锁: 
    * MySQL唯一索引、InnoDB排他锁
    * redis: setnx、Redission(lua、clientId、count、watch dog)、redlock(n/2 + 1)
    * Zookeeper: 临时顺序节点、watch
* Zookeeper选举算法: epoch、zxid、sid
* 限流: AtomicInteger、Semaphore、令牌桶(RateLimiter)、漏桶、缓存限流(时间窗口)
* 幂等: 分布式锁、redis去重(requestId)、数据库唯一性约束、状态机、多版本

#### MySQL

* B+Tree: 一页(16k)、树的高度、范围查询
* 索引: 聚集索引、非聚集索引、二级索引、联合索引、前缀索引、覆盖索引
* SQL优化: explain、join、where、like、表达式、order(索引排序)、limit(避免大的offset)
* 读写分离: 读压力、主从同步
* 分库分表: 数据量大、读写压力、无法join
* Log: Redo Log、Undo Log、binlog、慢查询日志
* ACID、事务隔离级别、MVCC、锁

#### Redis

* Redis Cluster: 16384个槽、mget(大括号)
* 避免大的value: 占用内存过大(导致淘汰)、IO
* 缓存穿透、缓存失效、缓存雪崩
* 热点缓存
    * 压力: 本地缓存、缓存多份数据
    * 失效导致数据库压力: 持久缓存、数据库限流、失效时间分散化、失效预填充
* 持久化: RDB(fork子进程)、AOF
* Pipeline
* 过期键删除策略: 惰性删除、定期删除
* 内存淘汰机制: lru、random、ttl、no

#### ElasticSearch

* Lucene索引结构: Term Index(term前缀)、Term Dictionary(二分查找)、Posting List

#### Kafka

* 解耦、削峰、异步化
* 高性能: batch批量发送、网络模型、零拷贝、内存文件映射、磁盘顺序IO
* 消息可靠投递:
    * ack=-1、retry>0
    * replicas>1、ISR>1、OSR不参与Master选举
    * 刷盘
        * log.flush.interval.messages
        * log.flush.interval.ms
        * log.flush.scheduler.interval.ms
    * enable.auto.commit=false、幂等
* 消息重复: Server幂等、消费幂等

#### 高性能

* 指标: QPS、响应时间
* 单机: CPU、IO
* 集群: 负载均衡

#### 高可用

* 负载均衡
* 冗余备份(失效转移)

#### 高并发

#### 微服务 & SOA

* 通信方式: ESB企业服务总线 去中心化(直连)
* 去中心化
* 服务划分粒度: 粗粒度 细粒度(拆分、快速迭代、扩展、隔离)
* 容器: 持续集成、自动化测试、自动化部署、扩容

#### 故障排查

* CPU: 是否飙高、top、jstack
* 频繁gc: gc log
* 内存溢出OOM: +HeapDumpOnOutOfMemoryError、jmap、jhat、MAT、大对象
    * 自增长的数据结构
    * 内存泄露(引用未释放)
    * 装载太多的类
    * 直接内存
* 业务异常: 业务日志

https://blog.csdn.net/h70614959/article/details/83109317

#### 离职原因

* 管理混乱、产品进度、没有太大的前景


[<< 上一篇: Maven](14-运维/Maven.md)
