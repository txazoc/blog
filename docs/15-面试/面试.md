### 面试

#### 算法

* 红黑树
    * 5条性质、高度(`O(logn)`)、最大高度不会超过最小高度的2倍
    * 增删改查最坏的时间复杂度: `O(logn)`
    * 牺牲部分平衡性来换取插入/删除时少量的旋转操作

#### Java

* HashMap为啥是2的幂: 减少碰撞(hash & 1111)、与运算(取模)
* ConcurrentHashMap(jdk8)
    * put: 数组(cas + volatile)、synchronized、链表(红黑树)
    * get: 数组(volatile)、value(volatile)
* 线程栈状态: RUNNABLE、BLOCKED、WAITING、TIMED_WAITING
* 线程池: 五大核心参数、四种拒绝策略
    * 单线程线程池、固定大小线程池、可缓存线程池、调度线程池、自定义线程池
    * 线程池中线程不要对外抛出异常(导致线程销毁/创建)
* 调度线程池: DelayedWorkQueue、优先级队列
* 线程数大小: CPU密集型(CPU * 1 ~ 2)、IO密集型(最佳线程数目 = ((线程等待时间 + 线程CPU时间) / 线程CPU时间) * CPU核心数)
* Future: 等待队列、park/unpark
* IO: 5种IO模型
* 序列化对比: jdk序列化、xml、json、Hessian、Thrift/ProtoBuf，时间、空间、描述文件、友好、跨平台
* 原子性、可见性、有序性
* volatile: 可见性(缓存一致性协议)、禁止指令重排序(内存屏障)
* CAS: 原子性(总线锁定、读改写)、禁止指令重排序、自旋CAS
* AQS: state、CAS、CLH同步队列、park/unpark、独占/共享
* 双重检查锁: 重排序问题、volatile
* synchronized & Lock
    * 加解锁: 隐式加锁解锁(关键字、monitorenter、monitorexit、ACC_SYNCHRONIZED方法标识)、显式加锁解锁(代码)
    * 用法: synchronized(三种用法)、lock/lockInterruptibly/tryLock/tryLock(time)
    * 锁类型: 锁升级(偏向锁、轻量级锁、自旋锁、重量级锁)、公平锁/非公平锁/读写锁
    * 优化: synchronized(锁消除、锁粗化)
    * 实现
        * synchronized: 对象头、偏向锁(CAS 对象头`Thread Id`)、轻量级锁(CAS 对象头`Mark Word`)、自旋锁(轻量级锁重试)、重量级锁(监视器锁、block阻塞队列、wait等待队列)
        * Lock: AQS、公平锁(抢占)/非公平锁(排队)/读写锁(state=高低位读锁写锁数量)
    * 等待/唤醒: 一个wait/notify等待队列、多个Condition等待队列
* 多线程同步: 不可变、局部变量、ThreadLocal、volatile、CAS(原子类)、锁、AQS(Semaphore、CountDownLatch、CyclicBarrier)、wait/notify、Condition.await/signal、join、concurrent包
* Java命令: jstack、jmap、jhat
* Reference
    * DirectByteBuffer -> Cleaner

#### JVM

* JVM内存结构: 程序计数器、Java虚拟机栈、本地方法栈、堆、方法区(Metaspace、永久代)
* `类加载`: 双亲委派、.class字节码、类文件格式(解析验证)、先加载父类
    * 准备: 类静态变量分配内存空间、静态基本类型常量赋值
    * 初始化: 静态代码块、静态变量、静态引用类型常量
* `对象初始化`: 分配内存空间、父类构造代码块/成员变量、父类构造方法、子类...
* GC Roots: 栈(线程栈帧、本地方法栈)、方法区(static变量、常量池)
* 垃圾收集算法: 复制、标记-整理、标记-清除
* young gc为什么快: 扫描对象少(线程栈 + Dirty Card)、存活对象少(copy少)
* 8种垃圾收集器:
    * Serial、Serial Old、ParNew、Parallel Scavenge、Parallel Old、CMS、G1
    * 新生代/老年代、串行/并行/并发、STW、垃圾收集算法
    * 垃圾收集器组合
* CMS: 4个过程
* 内存分配
    * 新生代: 新的对象
    * 老年代: 长期存活晋级的对象、大对象、Minor GC空间分配担保
* Minor GC
    * 新生代eden内存空间不足
    * -XX:+CMSScavengeBeforeRemark: 在执行CMS Remark前执行一次Young GC，减少GC Roots的数量，降低Remark的开销
    * Full GC时会先触发Minor GC，适用于`+UseParallelGC`
* Full GC
    * System.gc()
    * 老年代空间不足
    * 永久代空间/Metaspace不足
    * Minor GC前，老年代剩余空间小于历史晋升到老年代对象的平均大小
    * CMS GS promotion failed，Minor GC时，晋升对象/担保对象进入老年代，因碎片问题，无法分配内存空间，触发CMS Full GC
    * CMS GS concurrent mode failure，CMS GC时，大对象直接进入老年代，老年代空间不足，此时CMS GC退化为Serial Old GC
* JVM调优
    * 调优目标: gc时间少、gc频率低、吞吐量大、停顿时间少
    * 调什么: 代码层面(对象)、垃圾收集器选择、参数调整(内存大小及比例、线程数、其它)
* 内存溢出有哪些
    * 栈: 深递归调用
    * 堆
        * 内存引用未释放、资源未释放
        * 数据过大: 数据库查询数据过大、循环/递归创建大量对象
    * 永久代: 加载过多代理类未卸载
    * 直接内存: DirectByteBuffer
* JVM参数调优
    * -Xms、-Xmx、-XX:NewRatio=2、-XX:SurvivorRatio=8
    * -XX:PermSize、-XX:MaxPermSize
    * -XX:MetaspaceSize、-XX:MaxMetaspaceSize
    * -XX:MaxTenuringThreshold=15
    * GC收集器选择
    * GC收集器配置: -XX:ParallelGCThreads、-XX:MaxGCPauseMillis、-XX:GCTimeRatio
    * GC日志
    * -XX:HeapDumpOnOutOfMemoryError

#### 网络通信

* TCP: 三次握手、四次挥手、滑动窗口、数据包重组、重传
* TCP直连、HTTP连接池(长连接)
* Http请求全过程: 域名解析 -> ip -> tcp三次握手 -> http请求报文 -> 处理 -> http响应报文 -> tcp四次挥手

#### 开源框架

* Spring IOC
    * 扫描BeanDefinition、实例化bean、注入依赖、初始化bean(@PostConstruct、afterPropertiesSet()、init-method)
    * 循环依赖: singletonObjects、earlySingletonObjects、singletonFactories、构造器的循环依赖没法解决
    * `@Autowired`: 基于类型、@Primary、@Qualifier
    * `@Resource`: name + type
* Spring AOP: 在某些类或方法上做拦截处理、切入点Pointcut(类 + 方法) + 增强Advice(前置增强、后置增强、环绕增强、异常增强)、动态代理
* Spring事务: AOP、Spring事务传播机制、事务管理、commit、rollback
* Netty
    * Reactor模型: boss线程池(accept)、worker线程池(io读写、Handler事件链)、自定义Handler处理线程池
    * Handler事件驱动(Inbound、Outbound)、拆包粘包、ByteBuf(Zero Copy、池化)
* Tomcat: maxConnections(10000)、maxThreads(200)
* LVS: NAT、DR、TUN

#### 微服务

* Dubbo & Spring Cloud
    * 定位: RPC框架、微服务的一站式解决方案
    * 注册中心: Zookeeper、Eureka
    * 服务调用: RPC(二进制协议、hessian序列化、Netty、性能)、Restful API(json、Http、Spring MVC、灵活)
    * Spring Cloud一站式: API网关、配置中心、分布式链路追踪、断路器
    * Spring Cloud: Spring、Spring Boot
    * Dubbo: 服务治理
* Ribbon: 随机、轮询、加权响应时间、最小并发数
* Hystrix: 隔离、限流(信号量、线程池)、熔断(滑动时间窗口)、降级
    * 断路器状态: OPEN、HALF_OPEN、CLOSED
* Eureka: 服务提供者(register、心跳、replication)、服务消费者(fetch、refresh)、Server(去中心化、同步)
* Eureka Server三级缓存
    * registry: 注册表
    * readWriterCacheMap: 读写缓存
    * readOnlyCacheMap: 只读缓存(可禁用)
* Eureka缓存
    * Ribbon缓存: client.ribbon.ServerListRefreshInterval=30s
    * Eureka Client缓存: eureka.client.registry-fetch-interval-seconds=30s
    * Eureka Server缓存: eureka.server.response-cache-update-interval-ms=30s

#### 分布式

* CAP: C一致性(多副本一致)、A可用性(有限时间内返回正常结果)、P分区容错性(网络分区)
    * 分布式环境下，必须保证P，在C和A之间取舍
    * 保证可用性N个9、保证AP，牺牲C(强一致性)
* BASE: CAP理论的延伸，保证最终一致性
    * BA: 基本可用(Basically Available)，允许响应时间上的损失、功能损失(降级)
    * S: 软状态(Soft State)，允许存在中间状态
    * E: 最终一致性(Eventual Consistent)，弱一致性，保证最终一致性
* 分布式ID: UUID、redis incr、数据库分表步长、数据库发号器、雪花算法(1+41+10+12、时钟回拨)
* 分布式事务: 两阶段提交、TCC两阶段补偿、RocketMQ事务消息、本地消息表(MQ、轮询)
* 分布式锁: 可重入、阻塞、超时释放、单点问题
    * MySQL唯一索引、InnoDB排他锁
    * redis: setnx、Redission(lua、clientId、count、watch dog)、redlock(n/2 + 1)
    * Zookeeper: 临时顺序节点、watch
* Zookeeper选举算法: epoch、zxid、sid
* Zookeeper应用: 命名服务、配置管理(元数据)、集群管理(注册中心)、分布式锁、分布式队列
* 限流: AtomicInteger、Semaphore、令牌桶(RateLimiter)、漏桶、缓存限流(时间窗口)
* 幂等: 分布式锁、redis去重(requestId)、数据库唯一性约束、状态机、多版本

#### MySQL

* InnoDB & MyISAM
    * 聚集索引 非聚集索引
    * 事务
    * 表锁 行锁
* B+Tree: 一页(16k)、树的高度、范围查询
* 索引
    * 聚集索引、非聚集索引、二级索引、联合索引、前缀索引、覆盖索引、回表
    * 避免过多、优先整数、索引尽量小、索引列基数足够大(否则导致大量的回表操作)、最好自增
* SQL优化: explain、join、子查询、where、like、表达式、order(索引排序)、group by(索引排序)、limit(避免大的offset)
* explain
    * type: const(唯一索引)、eq_ref(唯一索引join)、ref(非唯一二级索引查询/join)、index_merge(索引查询合并)、range(索引范围查询)、index(全表扫描索引树)、ALL(全表扫描)
    * Extra: Using filesort(文件排序)、Using temporary(临时表)、Using index(覆盖索引)
* 读写分离: 读压力
* 主从同步
    * 主binlog -> 从relay log -> 从执行SQL
    * 异步复制、半同步复制、全同步复制
* 分库分表
    * 水平切分/垂直切分、数据量大、读写压力
    * 带来的问题: 分布式事务、跨节点join/order/limit、ID生成、扩容、分片策略
* Log
    * Redo Log(崩溃恢复): `innodb_flush_log_at_trx_commit`
    * Undo Log(回滚、MVCC)、binlog(主从同步)、慢查询日志
* ACID
* MVCC: 版本链、ReadView
* 锁
    * 表锁、意向锁、行锁
    * 记录锁、间隙锁、Next-Key锁、插入意向锁(幻读、并发)
    * 共享锁(S锁)、排它锁(X锁)
    * 悲观锁、乐观锁
* 事务隔离级别
    * READ UNCOMMITTED: select不加锁
    * READ COMMITTED: 一致性非锁定读(当前读)
    * REPEATABLE READ: 一致性非锁定读(快照读)，加Gap锁/Next-Key锁
    * SERIALIZABLE
* 一致性非锁定读(MVCC)、一致性锁定读(锁)

#### Redis

* 单线程原因: 内存读写快、线程上下文切换开销、IO多路复用、并发冲突
* Redis Cluster: 16384个槽、mget(大括号)
* 避免大的value: 占用内存过大(导致淘汰)、IO
* 缓存穿透、缓存失效、缓存雪崩
* 热点缓存
    * 压力: 本地缓存、缓存多份数据
    * 失效导致数据库压力: 持久缓存、数据库限流、失效时间分散化、失效预填充
* 持久化: RDB(fork子进程)、AOF
* Pipeline
* 过期键删除策略: 惰性删除、定期删除(事件循环)
* `内存淘汰机制`
    * volatile-lru、volatile-ttl、volatile-random
    * allkeys-lru、allkeys-random
    * no-eviction

#### ElasticSearch

* Lucene索引结构: Term Index(term前缀)、Term Dictionary(二分查找)、Posting List
* 字段: 精确值/全文、Multi-Field
* routing
* 避免深度分页、scroll
* 查询: term查询、filter查询(缓存)、bool查询(must、must_not、should、filter)
    * filter查询: 不计算_score，结果被缓存
    * query查询: 计算_score，结果不被缓存
* Lucene索引
    * 一个提交点(Commit Point)、多个段(Segment)
    * 一个提交点记录所有已提交的段，包含一个`.del`文件
    * 一个段包含多个字段的倒排索引，可以被搜索
* 写数据: 写`in-memory buffer`、记录translog
* refresh: `in-memory buffer` -> `Segment(os buffer)`
* flush: Segment(os buffer)fsync到磁盘，清空translog
* translog: 每5s落盘

#### Kafka

* 解耦、削峰、异步化
* 高性能: batch批量发送、网络模型、零拷贝、内存文件映射、磁盘顺序IO(读写)、批量消费
* 消息可靠投递:
    * ack=-1、retry>0(重试间隔大一点)
    * replicas>1、`min.insync.replicas`>1、OSR不参与Master选举
    * 刷盘
        * log.flush.interval.messages
        * log.flush.interval.ms
        * log.flush.scheduler.interval.ms
    * 关闭自动commit、幂等
* 消息重复: Server幂等、Consumer幂等
* Kafka幂等实现
    * `Producer Id`
    * <Topic, Partition>: 自增`Sequence Number`
    * Broker: 缓存的`Sequence Number` + 1 = 接收消息的`Sequence Number`
* HW(ISR中最小的LEO)、LEO(分区中下一条消息的offset)

#### 高性能

* 指标: QPS、响应时间
* 单机: CPU、IO
* 集群: 负载均衡

#### 高可用(4个9)

* 避免单点故障: 负载均衡、多机房、异地多活
* 存储: 数据分片、冗余备份、读写分离
* 压测
* 监控自动报警
* 隔离(进程隔离、线程池隔离)/限流/熔断/降级
* 超时/失败重试

#### 高并发

* 海量数据
* 高并发要求`高性能`
* 高并发要求`高可用`
* 高并发要求`可扩展`
* 高并发保证`数据一致性`

#### 微服务 & SOA

* 通信方式: ESB企业服务总线 去中心化(服务与服务直接通信)
* 服务划分粒度: 粗粒度 细粒度(拆分、快速迭代、扩展、隔离)
* 容器支持: 持续集成、自动化测试、自动化部署、扩容

#### 故障排查

* CPU: 是否飙高、top、jstack
* 频繁gc: gc log
* 内存溢出OOM: +HeapDumpOnOutOfMemoryError、jmap、jhat、MAT、大对象
    * 自增长的数据结构
    * 内存泄露(引用未释放)
    * 装载太多的类
    * 直接内存
* 业务异常: 业务日志

https://blog.csdn.net/h70614959/article/details/83109317

#### 优化

* MySQL优化
    * 架构: 分库分表、读写分离
    * 硬件: 缓冲池(内存)、磁盘(SSD)
    * 开启慢查询日志
    * Redo Log/binlog刷盘
    * 主从同步模式
    * 索引: 主键索引有序(插入)、优先整数、索引尽量小、索引列基数足够大、避免过多
    * 字段: 优先整数、尽量小、尽量定长、not null
    * SQL优化
        * explain
        * select 必需字段
        * 避免join和子查询
        * where: 索引、like、函数/表达式
        * order: 索引排序
        * group by: 索引排序
        * limit: 避免大的offset、避免大的分页
* Redis优化
    * 硬件: 网卡
    * 是否需要持久化: RDB(fork导致高并发延迟、redis内存不要过大)、AOF(每秒fysnc)
    * 批量: mget、pipeline、lua
    * key设置过期时间
    * 避免O(n)命令、避免大的value、append
    * 内存淘汰策略
    * 多级缓存
    * 缓存穿透、缓存失效、热点缓存、缓存雪崩
* Kafka优化
    * Producer: 异步发送、消息尽量小、buffer.memory、linger.ms、batch.size、acks
    * Broker: 分区数、刷盘、Java(内存、网络io)
    * Consumer: 消费者数量、批量fetch、多线程消费
* ES优化

#### 离职原因

* 管理混乱、产品进度慢、不稳定、没有太大的前景


[<< 上一篇: Maven](14-运维/Maven.md)
